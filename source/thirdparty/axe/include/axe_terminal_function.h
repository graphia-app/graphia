//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2012, GB Research, LLC (www.gbresearch.com)
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#ifndef AXE_TERMINAL_FUNCTION_H
#define AXE_TERMINAL_FUNCTION_H

#include <type_traits>
#include <utility>
#include "axe_composite.h"
#include "axe_terminal.h"
#include "axe_trait.h"

namespace axe {
    
    namespace detail {
        //-------------------------------------------------------------------------
        /// r_lit_traits traits template for literals
        //-------------------------------------------------------------------------
        template<class T, bool = std::is_arithmetic<typename std::remove_reference<T>::type>::value>
        struct r_lit_traits {};

        template<class T>
        struct r_lit_traits<T, true> { typedef r_bin_t<T> type; };

        template<>
        struct r_lit_traits<char> { typedef r_char_t<char> type; };

        template<>
        struct r_lit_traits<wchar_t> { typedef r_char_t<wchar_t> type; };

        template<>
        struct r_lit_traits<const char*> { typedef r_str_t<char> type; };

        template<>
        struct r_lit_traits<const wchar_t*> { typedef r_str_t<wchar_t> type; };

        //-------------------------------------------------------------------------
        /// r_val_traits template for value class types
        //-------------------------------------------------------------------------
        template<class T, bool = !AXE_IS_RULE(T)
            && std::is_class<typename std::remove_reference<T>::type>::value>
        struct r_val_traits {};

        template<class CharT, class TraitsT, class AllocT>
        struct r_val_traits<std::basic_string<CharT, TraitsT, AllocT>&, true> 
        { typedef r_str_t<std::basic_string<CharT, TraitsT, AllocT>&> type; };

        template<class CharT, class TraitsT, class AllocT>
        struct r_val_traits<std::basic_string<CharT, TraitsT, AllocT>, true> 
        { typedef r_str_t<std::basic_string<CharT, TraitsT, AllocT>> type; };
    }


    //-------------------------------------------------------------------------
    /// AND rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename std::enable_if<!AXE_IS_RULE(R2), 
            typename detail::r_lit_traits<R2>::type>::type
    >
    operator& (R1&& r1, R2 r2)
    {
        return r_and_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// AND rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename detail::r_val_traits<R2>::type
    >
    operator& (R1&& r1, R2&& r2)
    {
        return r_and_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_and_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator& (R1 r1, R2&& r2)
    {
        return r_and_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// AND rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_and_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator& (const CharT* r1, R&& r2)
    {
        return r_and_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// AND rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_and_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator& (char r1, R&& r2)
    {
        return r_and_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// AND rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_and_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator& (wchar_t r1, R&& r2)
    {
        return r_and_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif
    //-------------------------------------------------------------------------
    /// OR rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_or_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename std::enable_if<!AXE_IS_RULE(R2), 
            typename detail::r_lit_traits<R2>::type>::type
    >
    operator| (R1&& r1, R2 r2)
    {
        return r_or_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// OR rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_or_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
            typename detail::r_val_traits<R2>::type
    >
    operator| (R1&& r1, R2&& r2)
    {
        return r_or_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_or_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator| (R1 r1, R2&& r2)
    {
        return r_or_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// OR rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_or_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator| (const CharT* r1, R&& r2)
    {
        return r_or_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// OR rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_or_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator| (char r1, R&& r2)
    {
        return r_or_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// OR rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_or_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator| (wchar_t r1, R&& r2)
    {
        return r_or_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif

    //-------------------------------------------------------------------------
    /// || rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_seq_or_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename std::enable_if<!AXE_IS_RULE(R2), 
            typename detail::r_lit_traits<R2>::type>::type
    >
    operator|| (R1&& r1, R2 r2)
    {
        return r_seq_or_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// || rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_seq_or_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
            typename detail::r_val_traits<R2>::type
    >
    operator|| (R1&& r1, R2&& r2)
    {
        return r_seq_or_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_seq_or_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator|| (R1 r1, R2&& r2)
    {
        return r_seq_or_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// || rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_seq_or_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator|| (const CharT* r1, R&& r2)
    {
        return r_seq_or_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// || rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_seq_or_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator|| (char r1, R&& r2)
    {
        return r_seq_or_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// || rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_seq_or_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator|| (wchar_t r1, R&& r2)
    {
        return r_seq_or_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif
 
    //-------------------------------------------------------------------------
    /// XOR rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_xor_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type,
        typename std::enable_if<!AXE_IS_RULE(R2), 
        typename detail::r_lit_traits<R2>::type>::type
    >
    operator^ (R1&& r1, R2 r2)
    {
        return r_xor_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// XOR rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_xor_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename detail::r_val_traits<R2>::type
    >
    operator^ (R1&& r1, R2&& r2)
    {
        return r_xor_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_xor_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator^ (R1 r1, R2&& r2)
    {
        return r_xor_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1),
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// XOR rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_xor_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator^ (const CharT* r1, R&& r2)
    {
        return r_xor_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// XOR rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_xor_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator^ (char r1, R&& r2)
    {
        return r_xor_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }
    
    //-------------------------------------------------------------------------
    /// XOR rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_xor_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator^ (wchar_t r1, R&& r2)
    {
        return r_xor_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif

    //-------------------------------------------------------------------------
    /// unordered AND rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_unordered_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename std::enable_if<!AXE_IS_RULE(R2), 
            typename detail::r_lit_traits<R2>::type>::type
    >
    operator&& (R1&& r1, R2 r2)
    {
        return r_unordered_and_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// unordered AND rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_unordered_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename detail::r_val_traits<R2>::type
    >
    operator&& (R1&& r1, R2&& r2)
    {
        return r_unordered_and_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_unordered_and_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator&& (R1 r1, R2&& r2)
    {
        return r_unordered_and_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// unordered AND rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_unordered_and_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator&& (const CharT* r1, R&& r2)
    {
        return r_unordered_and_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// unordered AND rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_unordered_and_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator&& (char r1, R&& r2)
    {
        return r_unordered_and_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// unordered AND rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_unordered_and_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator&& (wchar_t r1, R&& r2)
    {
        return r_unordered_and_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif


    //-------------------------------------------------------------------------
    /// atomic rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_atomic_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename std::enable_if<!AXE_IS_RULE(R2), 
            typename detail::r_lit_traits<R2>::type>::type
    >
    operator> (R1&& r1, R2 r2)
    {
        return r_atomic_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2));
    }

    //-------------------------------------------------------------------------
    /// atomic rule for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_atomic_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type, 
        typename detail::r_val_traits<R2>::type
    >
    operator> (R1&& r1, R2&& r2)
    {
        return r_atomic_t<R1, typename detail::r_val_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_val_traits<R2>::type>(std::forward<R2>(r2)));
    }

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_atomic_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    operator> (R1 r1, R2&& r2)
    {
        return r_atomic_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2));
    }
#else
    //-------------------------------------------------------------------------
    /// atomic rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R>
    r_atomic_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator> (const CharT* r1, R&& r2)
    {
        return r_atomic_t<r_str_t<CharT>, R>(r_str_t<CharT>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// atomic rule for char literals
    //-------------------------------------------------------------------------
    template<class R>
    r_atomic_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator> (char r1, R&& r2)
    {
        return r_atomic_t<r_char_t<char>, R>(r_char_t<char>(r1), std::forward<R>(r2));
    }

    //-------------------------------------------------------------------------
    /// atomic rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R>
    r_atomic_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R), R>::type
    >
    operator> (wchar_t r1, R&& r2)
    {
        return r_atomic_t<r_char_t<wchar_t>, R>(r_char_t<wchar_t>(r1), std::forward<R>(r2));
    }
#endif


    //-------------------------------------------------------------------------
    /// operator- for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), 
            r_not_t<typename detail::r_lit_traits<R2>::type>>::type,
        typename std::enable_if<!AXE_IS_RULE(R2)
            && !std::is_class<typename std::remove_reference<R2>::type>::value, R1>::type
    >
    operator- (R1&& r1, R2 r2)
    {
        typedef typename detail::r_lit_traits<R2>::type type;
        return r_and_t<r_not_t<type>, R1>(r_not_t<type>(type(r2)), std::forward<R1>(r1));
    }

    //-------------------------------------------------------------------------
    /// operator- for value classes
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_and_t<
        typename std::enable_if<AXE_IS_RULE(R1), 
            r_not_t<typename detail::r_val_traits<R2>::type>>::type,
        typename std::enable_if<!AXE_IS_RULE(R2)
            && std::is_class<typename std::remove_reference<R2>::type>::value, R1>::type
    >
    operator- (R1&& r1, R2&& r2)
    {
        typedef typename detail::r_val_traits<R2>::type type;
        return r_and_t<r_not_t<type>, R1>(r_not_t<type>(type(std::forward<R2>(r2))), std::forward<R1>(r1));
    }

    //-------------------------------------------------------------------------
    /// r_many rule for literals
    //-------------------------------------------------------------------------
    template<class R1, class R2>
    r_many_t<
        typename std::enable_if<AXE_IS_RULE(R1), R1>::type,
        typename std::enable_if<!AXE_IS_RULE(R2)
        // avoid overload ambiguity between r_many(r, 0) and r_many(r, detail::r_lit_traits<int>(0))
        && (!std::is_convertible<R2, size_t>::value | std::is_same<R2, char>::value | std::is_same<R2, wchar_t>::value), 
        typename detail::r_lit_traits<R2>::type>::type
    >
    r_many (R1&& r1, R2 r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<R1, typename detail::r_lit_traits<R2>::type>(std::forward<R1>(r1), 
            static_cast<typename detail::r_lit_traits<R2>::type>(r2), min_occurrence, max_occurrence);
    }
#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_many_t<
        typename detail::r_lit_traits<R1>::type,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    r_many (R1 r1, R2&& r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<typename detail::r_lit_traits<R1>::type, R2>(typename detail::r_lit_traits<R1>::type(r1), 
            std::forward<R2>(r2), min_occurrence, max_occurrence);
    }
#else
    //-------------------------------------------------------------------------
    /// r_many rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT, class R2>
    r_many_t<
        r_str_t<CharT>,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    r_many (const CharT* r1, R2&& r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<r_str_t<CharT>, R2>(r_str_t<CharT>(r1), std::forward<R2>(r2), min_occurrence, max_occurrence);
    }
    //-------------------------------------------------------------------------
    /// r_many rule for char literals
    //-------------------------------------------------------------------------
    template<class R2>
    r_many_t<
        r_char_t<char>,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    r_many (char r1, R2&& r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<r_char_t<char>, R2>(r_char_t<char>(r1), std::forward<R2>(r2), min_occurrence, max_occurrence);
    }
    //-------------------------------------------------------------------------
    /// r_many rule for wchar_t literals
    //-------------------------------------------------------------------------
    template<class R2>
    r_many_t<
        r_char_t<wchar_t>,
        typename std::enable_if<AXE_IS_RULE(R2), R2>::type
    >
    r_many (wchar_t r1, R2&& r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<r_char_t<wchar_t>, R2>(r_char_t<wchar_t>(r1), std::forward<R2>(r2), min_occurrence, max_occurrence);
    }
#endif

#ifdef AXE_USE_LIT_TRAITS
    //-------------------------------
    template<class R1, class R2>
    r_many_t<
        typename detail::r_lit_traits<R1>::type,
        typename detail::r_lit_traits<R2>::type
    >
    r_many (R1 r1, R2 r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<typename detail::r_lit_traits<R1>::type, typename detail::r_lit_traits<R2>::type>(
            typename detail::r_lit_traits<R1>::type(r1), 
            typename detail::r_lit_traits<R1>::type(r2), min_occurrence, max_occurrence);
    }
#else
    //-------------------------------------------------------------------------
    /// r_many rule for string literals
    //-------------------------------------------------------------------------
    template<class CharT>
    r_many_t<r_str_t<CharT>, r_str_t<CharT>>
    r_many (const CharT* r1, const CharT* r2, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<r_str_t<CharT>, r_str_t<CharT>>(r_str_t<CharT>(r1), r_str_t<CharT>(r2), min_occurrence, max_occurrence);
    }
#endif

    //-------------------------------------------------------------------------
    /// r_many rule for literals
    //-------------------------------------------------------------------------
    template<class R>
    r_many_t<
        typename std::enable_if<!AXE_IS_RULE(R), 
            typename detail::r_lit_traits<R>::type>::type,
        r_empty_t>
    r_many (R r, size_t min_occurrence = 1, size_t max_occurrence = -1)
    {
        return r_many_t<typename detail::r_lit_traits<R>::type, r_empty_t>(
            static_cast<typename detail::r_lit_traits<R>::type>(r), r_empty_t(), min_occurrence, max_occurrence);
    }


    //-------------------------------------------------------------------------
    /// rule evaluates boolean expression when matching
    //-------------------------------------------------------------------------
    template<class BoolT>
    inline r_bool_t<
        typename std::enable_if<!AXE_IS_RULE(BoolT), BoolT>::type
    >
    r_bool (BoolT&& b) { return r_bool_t<BoolT>(std::forward<BoolT>(b)); }

    //-------------------------------------------------------------------------
    /// r_empty rule matches anything and doesn't advance iterator
    //-------------------------------------------------------------------------
    inline r_empty_t r_empty () { return r_empty_t(); }

    //-------------------------------------------------------------------------
    /// r_bin rule performs binary match and reads the value
    //-------------------------------------------------------------------------
    template<class T>
    inline r_bin_t<
        typename std::enable_if<!AXE_IS_RULE(T), T>::type
    > 
    r_bin (T&& t) { return r_bin_t<T>(std::forward<T>(t)); }

    //-------------------------------------------------------------------------
    /// r_lit rule matches specified literal
    //-------------------------------------------------------------------------
    template<class T>
    inline 
        typename std::enable_if<!AXE_IS_RULE(T),
        typename detail::r_lit_traits<T>::type>::type
    r_lit (T t) { return static_cast<typename detail::r_lit_traits<T>::type>(t); }

    //-------------------------------------------------------------------------
    /// r_char rule matches specified character
    //-------------------------------------------------------------------------
    template<typename T>
    inline 
        typename std::enable_if<!AXE_IS_RULE(T), r_char_t<T>>::type
    r_char (T c) { return r_char_t<T>(c); }

    //-------------------------------------------------------------------------
    /// r_str rule matches specified 0-terminated string (final 0 is not matched)
    //-------------------------------------------------------------------------
    template<typename T>
    inline 
        typename std::enable_if<!AXE_IS_RULE(T), r_str_t<T>>::type
    r_str (const T* str) { return r_str_t<T>(str); }

    //-------------------------------------------------------------------------
    /// r_str rule matches specified std::string lvalue
    //-------------------------------------------------------------------------
    template<class CharT, class TraitsT, class AllocT>
    inline
        r_str_t<std::basic_string<CharT, TraitsT, AllocT>&>
    r_str (const std::basic_string<CharT, TraitsT, AllocT>& str) 
    { 
        return r_str_t<std::basic_string<CharT, TraitsT, AllocT>&>(str); 
    }

    //-------------------------------------------------------------------------
    /// r_str rule matches specified std::string rvalue
    //-------------------------------------------------------------------------
    template<class CharT, class TraitsT, class AllocT>
    inline
        r_str_t<std::basic_string<CharT, TraitsT, AllocT>>
    r_str (std::basic_string<CharT, TraitsT, AllocT>&& str) 
    { 
        return r_str_t<std::basic_string<CharT, TraitsT, AllocT>>(std::move(str));
    }

    //-------------------------------------------------------------------------
    /// r_pred rule matches specified predicate
    //-------------------------------------------------------------------------
    template<class Pred>
    r_pred_t<Pred> r_pred (Pred&& pred) { return r_pred_t<Pred>(std::forward<Pred>(pred)); }

    //-------------------------------------------------------------------------
    /// r_predstr rule matches a predicate string
    //-------------------------------------------------------------------------
    template<class Pred>
    r_predstr_t<Pred> r_predstr (Pred&& pred) { return r_predstr_t<Pred>(std::forward<Pred>(pred)); }

    //-------------------------------------------------------------------------
    /// r_predstr rule matches a predicate string
    //-------------------------------------------------------------------------
    template<class Pred>
    r_predstr_t<Pred, true> r_predstr (Pred&& pred, size_t occurrence) 
    { return r_predstr_t<Pred, true>(std::forward<Pred>(pred), occurrence, occurrence); }

    //-------------------------------------------------------------------------
    /// r_predstr rule matches a predicate string
    //-------------------------------------------------------------------------
    template<class Pred>
    r_predstr_t<Pred, true> r_predstr (Pred&& pred, size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr_t<Pred, true>(std::forward<Pred>(pred), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_var rule matches variable and reads its value
    //-------------------------------------------------------------------------
    template<class T>
    r_var_t<T> r_var (T& t) { return r_var_t<T>(t); }

    //-------------------------------------------------------------------------
    /// r_array rule matches static array of rules
    //-------------------------------------------------------------------------
    template<class T, size_t N>
    r_array_t<T, N> r_array (std::array<T, N>& a) { return r_array_t<T, N>(a); }

    //-------------------------------------------------------------------------
    /// r_sequence rule matches and reads sequence of specified length
    //-------------------------------------------------------------------------
    template<class C>
    r_sequence_t<C> r_sequence (C& buf, size_t min_occurrence = 0, size_t max_occurrence = -1) 
    { 
        return r_sequence_t<C>(buf, min_occurrence, max_occurrence); 
    }

    //-------------------------------------------------------------------------
    /// r_ident rule matches identifier
    //-------------------------------------------------------------------------
    inline r_ident_t r_ident () { return r_ident_t(); }

    //-------------------------------------------------------------------------
    /// r_alpha rule matches single alpha character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_alpha> r_alpha() { return r_pred(is_alpha()); }

    //-------------------------------------------------------------------------
    /// r_alphastr rule marches a string of alpha characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alpha> r_alphastr() { return r_predstr(is_alpha()); }

    //-------------------------------------------------------------------------
    /// r_alphastr rule marches a string of alpha characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alpha, true> r_alphastr(size_t occurrence) 
    { return r_predstr(is_alpha(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_alphastr rule marches a string of alpha characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alpha, true> r_alphastr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_alpha(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_num rule matches a signle numeric character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_num> r_num(){ return r_pred(is_num()); }

    //-------------------------------------------------------------------------
    /// r_numstr rule matches a string of numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_num> r_numstr(){ return r_predstr(is_num()); }

    //-------------------------------------------------------------------------
    /// r_numstr rule matches a string of numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_num, true> r_numstr(size_t occurrence)
    { return r_predstr(is_num(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_numstr rule matches a string of numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_num, true> r_numstr(size_t min_occurrence, size_t max_occurrence)
    { return r_predstr(is_num(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_alnum rule matches a single alpha-numeric character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_alnum> r_alnum() { return r_pred(is_alnum()); }

    //-------------------------------------------------------------------------
    /// r_alnumstr matches a string of alpha-numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alnum> r_alnumstr() { return r_predstr(is_alnum()); }

    //-------------------------------------------------------------------------
    /// r_alnumstr matches a string of alpha-numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alnum, true> r_alnumstr(size_t occurrence) 
    { return r_predstr(is_alnum(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_alnumstr matches a string of alpha-numeric characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_alnum, true> r_alnumstr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_alnum(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_oct rule matches a single octadecimal character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_oct> r_oct() { return r_pred(is_oct()); }

    //-------------------------------------------------------------------------
    /// r_octstr rule matches a string of octadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_oct> r_octstr() { return r_predstr(is_oct()); }

    //-------------------------------------------------------------------------
    /// r_octstr rule matches a string of octadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_oct, true> r_octstr(size_t occurrence) 
    { return r_predstr(is_oct(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_octstr rule matches a string of octadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_oct, true> r_octstr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_oct(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_hex rule matches a single hexadecimal character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_hex> r_hex() { return r_pred(is_hex()); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_hex> r_hexstr() { return r_predstr(is_hex()); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_hex, true> r_hexstr(size_t occurrence) 
    { return r_predstr(is_hex(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_hex, true> r_hexstr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_hex(), min_occurrence, max_occurrence); }

    
    //-------------------------------------------------------------------------
    /// r_binary rule matches a single binary character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_bin> r_binary() { return r_pred(is_bin()); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_bin> r_binstr() { return r_predstr(is_bin()); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_bin, true> r_binstr(size_t occurrence) 
    { return r_predstr(is_bin(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_hexstr rule matches a string of hexadecimal characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_bin, true> r_binstr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_bin(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_printable rule matches a single printable character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_printable> r_printable() { return r_pred(is_printable()); }

    //-------------------------------------------------------------------------
    /// r_printablestr rule matches a string of printable characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_printable> r_printablestr() { return r_predstr(is_printable()); }

    //-------------------------------------------------------------------------
    /// r_printablestr rule matches a string of printable characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_printable, true> r_printablestr(size_t occurrence) 
    { return r_predstr(is_printable(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_printablestr rule matches a string of printable characters
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_printable, true> r_printablestr(size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_printable(), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_any rule matches a single character in the range [from, to]
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_pred_t<is_any_t<CharT>> r_any(CharT from, CharT to) 
    { return r_pred(is_any_t<CharT>(from, to)); }

    //-------------------------------------------------------------------------
    /// r_any rule matches a single character present in the specified string
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_pred_t<is_any_t<const CharT*>> r_any(const CharT* str) 
    { return r_pred(is_any_t<const CharT*>(str)); }

    //-------------------------------------------------------------------------
    /// r_any rule matches any single character
    //-------------------------------------------------------------------------
    inline r_pred_t<is_any_t<void>> r_any() { return r_pred(is_any_t<void>()); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters in the range [from, to]
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<CharT>> r_anystr(CharT from, CharT to) 
    { return r_predstr(is_any_t<CharT>(from, to)); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of any characters specified length
    //-------------------------------------------------------------------------
    inline r_predstr_t<is_any_t<void>, true> r_anystr(size_t occurrence) 
    { return r_predstr(is_any_t<void>(), occurrence); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters in the range [from, to]
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<CharT>, true> r_anystr(CharT from, CharT to, size_t occurrence) 
    { return r_predstr(is_any_t<CharT>(from, to), occurrence); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters in the range [from, to]
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<CharT>, true> r_anystr(CharT from, CharT to, size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_any_t<CharT>(from, to), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters present in the specified string
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<const CharT*>> r_anystr(const CharT* str) 
    { return r_predstr(is_any_t<const CharT*>(str)); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters present in the specified string
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<const CharT*>, true> r_anystr(const CharT* str, size_t occurrence) 
    { return r_predstr(is_any_t<const CharT*>(str), occurrence); }

    //-------------------------------------------------------------------------
    /// r_anystr rule matches a string of characters present in the specified string
    //-------------------------------------------------------------------------
    template<class CharT>
    inline r_predstr_t<is_any_t<const CharT*>, true> r_anystr(const CharT* str, size_t min_occurrence, size_t max_occurrence) 
    { return r_predstr(is_any_t<const CharT*>(str), min_occurrence, max_occurrence); }

    //-------------------------------------------------------------------------
    /// r_end rule matches the end of range
    //-------------------------------------------------------------------------
    inline r_end_t r_end() { return r_end_t(); }

    //-------------------------------------------------------------------------
    /// r_advance rule matches if it can advance the iterator by offset
    //-------------------------------------------------------------------------
    template<class OffsetT>
    typename std::enable_if<
        std::is_arithmetic<typename std::remove_reference<OffsetT>::type>::value,
        r_advance_t<OffsetT> 
    >::type
    r_advance (OffsetT&& offset)
    {
        return r_advance_t<OffsetT>(std::forward<OffsetT>(offset));
    }

    //-------------------------------------------------------------------------
    /// r_token rule matches the specified token
    //-------------------------------------------------------------------------
    template<typename T>
    inline
        typename std::enable_if<!AXE_IS_RULE(T), r_token_t<T>>::type
    r_token (T&& token) 
    { 
        return r_token_t<T>(std::forward<T>(token)); 
    }
    
    //-------------------------------------------------------------------------
    /// r_range rule matches the specified iterator range
    //-------------------------------------------------------------------------
    template<typename Iterator>
    inline r_range_t<Iterator> r_range (Iterator begin, Iterator end)
    { 
        return r_range_t<Iterator>(begin, end); 
    }

    //-------------------------------------------------------------------------
    /// r_range rule matches (begin,end) range of the specified container
    //-------------------------------------------------------------------------
    template<typename Container>
    inline r_range_t<typename Container::const_iterator> r_range (const Container& c)
    { 
        return r_range_t<typename Container::const_iterator>(c.begin(), c.end());
    }
}

#endif
