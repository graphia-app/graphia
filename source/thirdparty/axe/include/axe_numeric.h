//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2012, GB Research, LLC (www.gbresearch.com)
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#ifndef AXE_NUMERIC_H
#define AXE_NUMERIC_H

#include "axe_composite_function.h"
#include "axe_terminal_function.h"
#include "axe_extractor_function.h"
#include "axe_trait.h"

namespace axe {

    //-------------------------------------------------------------------------
    /// r_udecimal_t rule matches unsigned decimal number
    //-------------------------------------------------------------------------
    template<class T = void>
    struct r_udecimal_t AXE_RULE
    {
        T& number_;
    public:
        explicit r_udecimal_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            auto match = r_numstr()(i1, i2);

            if(match.matched_)
            {
                number_ = 0;
                
                for(;i1 != match.position_; ++i1)
                    number_ = number_ * 10 + *i1 - '0';
            }
            return match;
        }
    };

    //-------------------------------------------------------------------------
    template<>
    struct r_udecimal_t<void> AXE_RULE
    {
    public:
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return r_numstr()(i1, i2);
        }
    };

    //-------------------------------------------------------------------------
    /// r_decimal_t rule matches signed decimal number
    //-------------------------------------------------------------------------
    template<class T = void>
    struct r_decimal_t AXE_RULE
    {
        T&  number_;
    public:

        explicit r_decimal_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            char sign = 0;

            result<Iterator> match = 
                (
                ~(r_char('-') >> sign | '+') // optional sign
                & ~r_predstr(is_space()) // optional spaces
                & r_udecimal_t<T>(number_)
                )(i1, i2);

            if(match.matched_ && sign == '-')
                number_ *= -1;

            return match;
        }
    };

    //-------------------------------------------------------------------------
    template<>
    struct r_decimal_t<void> AXE_RULE
    {
    public:

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return
                (
                ~(r_char('-') | '+') // optional sign
                & ~r_predstr(is_space()) // optional spaces
                & r_udecimal_t<>()
                )(i1, i2);
        }
    };

    //-------------------------------------------------------------------------
    /// r_hex_t rule matches unsigned hex number
    //-------------------------------------------------------------------------
    template<class T>
    class r_hex_t AXE_RULE
    {
        T& number_;
    public:
        explicit r_hex_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            auto match = r_hexstr()(i1, i2);

            if(match.matched)
            {
                number_ = 0;

                for(;i1 != match.position; ++i1)
                    number_ = number_ * 16 + convert(i1);
            }
            return match;
        }
    private:
        template<class Iterator>
        static T convert(Iterator i)
        {
            return *i >= '0' && *i <= '9' ? *i - '0'
                : *i >= 'A' && *i <= 'F' ? *i - 'A' + 10
                : *i - 'a' + 10;
        }
    };

    //-------------------------------------------------------------------------
    /// r_oct_t rule matches unsigned oct number
    //-------------------------------------------------------------------------
    template<class T>
    class r_oct_t AXE_RULE
    {
        T& number_;
    public:
        explicit r_oct_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            auto match = r_octstr()(i1, i2);

            if(match.matched)
            {
                number_ = 0;

                for(;i1 != match.position; ++i1)
                    number_ = number_ * 8 + *i1 - '0';
            }

            return match;
        }
    };

    //-------------------------------------------------------------------------
    /// r_binary_t rule matches unsigned binary number
    //-------------------------------------------------------------------------
    template<class T>
    class r_binary_t AXE_RULE
    {
        T& number_;
    public:
        explicit r_binary_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            auto match = r_binstr()(i1, i2);

            if(match.matched)
            {
                number_ = 0;

                for(;i1 != match.position; ++i1)
                    number_ = number_ * 2 + *i1 - '0';
            }

            return match;
        }
    };

    //-------------------------------------------------------------------------
    /// r_ufixed_t rule matches unsigned fixed-point number
    //-------------------------------------------------------------------------
    template<class T = void>
    class r_ufixed_t AXE_RULE
    {
        T& number_;
    public:
        explicit r_ufixed_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            unsigned u1 = 0;
            unsigned u2 = 0;
            unsigned length = 0;

            result<Iterator> result = 
                (
                r_udecimal_t<unsigned>(u1) 
                & ~('.' & ~(r_udecimal_t<unsigned>(u2) >> e_length(length)))
                | '.' & r_udecimal_t<unsigned>(u2) >> e_length(length)
                )(i1, i2);

            if(result.matched_)
            {
                number_ = u1 + u2 / pow(T(10), T(length));
            }

            return make_result(result.matched_, result.position_, i1);
        }
    };

    //-------------------------------------------------------------------------
    template<>
    class r_ufixed_t<void> AXE_RULE
    {
    public:
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return
                (
                r_udecimal_t<>() 
                & ~('.' & ~r_udecimal_t<>())
                | '.' & r_udecimal_t<>()
                )(i1, i2);
        }
    };

    //-------------------------------------------------------------------------
    /// r_fixed_t rule matches signed fixed-point number
    //-------------------------------------------------------------------------
    template<class T = void>
    class r_fixed_t AXE_RULE
    {
        T&  number_;
    public:

        explicit r_fixed_t(T& number) : number_(number) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            char sign = 0;
            
            result<Iterator> result = // optional sign
                (
                ~(r_char('-') >> sign | '+')
                & ~r_predstr(is_space())
                & r_ufixed_t<T>(number_)
                )(i1, i2);
            
            if(result.matched_ && sign == '-')
                number_ *= -1;

            return result;
        }
    };

    //-------------------------------------------------------------------------
    template<>
    class r_fixed_t<void> AXE_RULE
    {
    public:
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return
                (
                ~(r_char('-') | '+')
                & ~r_predstr(is_space())
                & r_ufixed_t<>()
                )(i1, i2);
        }
    };

    //-------------------------------------------------------------------------
    /// r_double_t matches floating point number
    //-------------------------------------------------------------------------
    template<class T = void>
    class r_double_t AXE_RULE
    {
        T& d_;

    public:

        explicit r_double_t(T& d) : d_(d) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            char sign(0);
            unsigned i(0);
            unsigned frac(0);
            int flen(0);
            int e(0);

            result<Iterator> result = 
                (
                ~(r_lit('-') >> sign | '+')
                & ~r_predstr(is_space()) 
                & 
                (
                (r_udecimal_t<unsigned>(i) & ~('.' & ~r_udecimal_t<unsigned>(frac) >> e_length(flen)))
                | ('.' & r_udecimal_t<unsigned>(frac) >> e_length(flen))
                )
                & ~(r_any("eE") & r_decimal_t<int>(e))
                )(i1, i2);

            if(result.matched_)
                d_ = (sign == '-' ? -1 : 1) * (T(i) + frac / pow(T(10), T(flen))) * pow(T(10), T(e));

            return result;
        }
    };

    //-------------------------------------------------------------------------
    template<>
    class r_double_t<void> AXE_RULE
    {
    public:
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return
                (
                ~(r_lit('-') | '+')
                & ~r_predstr(is_space()) 
                & 
                (
                r_udecimal_t<>() & ~('.' & ~r_udecimal_t<>())
                | '.' & r_udecimal_t<>()
                )
                & ~(r_any("eE") & r_decimal_t<>())
                )(i1, i2);
        }
    };

}
#endif
