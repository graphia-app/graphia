//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2012, GB Research, LLC (www.gbresearch.com)
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#ifndef AXE_TERMINAL_H
#define AXE_TERMINAL_H

#include <array>
#include <iterator>
#include <string>
#include <sstream>
#include <math.h>
#include <utility>
#include <stddef.h>

#include "axe_result.h"
#include "axe_predicate.h"
#include "axe_composite.h"

namespace axe {

    //-------------------------------------------------------------------------
    /// r_bool_t rule allows including boolean expression evaluated at parse time
    //-------------------------------------------------------------------------
    template<class BoolT, bool = std::is_convertible<BoolT, bool>::value>
    class r_bool_t AXE_RULE
    {
        BoolT b_; // lambda function returning bool
    public:
        explicit r_bool_t(BoolT&& b) : b_(b) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator) const
        {
            return make_result(b_(), i1);
        }

        const char* name() const { return "r_bool(lambda)"; }
    };
    // specialization for bool convertible types
    template<class BoolT>
    class r_bool_t<BoolT, true> AXE_RULE
    {
        BoolT b_; // 
    public:
        explicit r_bool_t(BoolT&& b) : b_(b) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator) const
        {
            return make_result(b_, i1);
        }

        const char* name() const { return "r_bool(bool)"; }
    };

    //-------------------------------------------------------------------------
    /// Empty rule always return match and doesn't advance iterator
    //-------------------------------------------------------------------------
    struct r_empty_t AXE_RULE
    {
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator) const
        {
            return make_result(true, i1);
        }

        const char* name() const { return "r_empty"; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform single character match
    //-------------------------------------------------------------------------
    template<class CharT>
    class r_char_t AXE_RULE
    {
        CharT t_;

    public:
        explicit r_char_t(CharT t) : t_(t) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(std::is_convertible<decltype(*i1), CharT>::value, "*i1 must be convertible to CharT");
            return i1 != i2 && t_ == *i1 ? make_result(true, ++i1) : make_result(false, i1);
        }

        const char* name() const { return "r_char"; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform token match for input sequence of tokens
    //-------------------------------------------------------------------------
    template<class T>
    class r_token_t AXE_RULE
    {
        T token_;

    public:
        explicit r_token_t(T&& token) : token_(std::forward<T>(token)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return i1 != i2 && token_ == *i1 ? make_result(true, ++i1) : make_result(false, i1);
        }

        const char* name() const { return "r_token"; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform binary match
    //-------------------------------------------------------------------------
    template<class T>
    class r_bin_t AXE_RULE
    {
        T t_;

    public:
        explicit r_bin_t(T&& t) : t_(std::forward<T>(t)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(sizeof(*i1) == 1, "iterator must be byte size for binary match");

            bool matched =  i1 != i2;
            Iterator i = i1;
            const unsigned char* p = reinterpret_cast<const unsigned char*>(&t_);
            size_t s = 0;
            // compare each byte
            for(; matched && s < sizeof(T) && i != i2; ++i, ++s)
                matched = p[s] == *i;
            // must match all bytes in T
            return make_result(matched && s == sizeof(T), i);
        }

        const char* name() const { return "r_bin"; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform value match for 0 terminated strings
    //-------------------------------------------------------------------------
    template<class CharT>
    class r_str_t AXE_RULE
    {
        const CharT* str_;

    public:
        explicit r_str_t(const CharT* str) : str_(str) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(std::is_convertible<decltype(*i1), CharT>::value, "*i1 must be convertible to CharT");

            // empty string always match
            if(!str_ || !str_[0])
                return make_result(true, i1);

            size_t s = 0;
            for(; i1 != i2 && str_[s] && str_[s] == *i1; ++s, ++i1);
            return make_result(!str_[s], i1);
        }

        const CharT* name() const { return str_; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform value match for std::string lvalues
    //-------------------------------------------------------------------------
    template<class CharT, class TraitsT, class AllocT>
    class r_str_t<std::basic_string<CharT, TraitsT, AllocT>&> AXE_RULE
    {
        typedef std::basic_string<CharT, TraitsT, AllocT> StringT;
        const StringT& str_;

        r_str_t(StringT&& str); // = delete
    public:
        explicit r_str_t(const StringT& str) : str_(str) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(std::is_convertible<decltype(*i1), CharT>::value, "*i1 must be convertible to CharT");
            auto i = str_.begin();
            auto str_end = str_.end();
            for(; i1 != i2 && i != str_end && *i == *i1; ++i, ++i1);
            return make_result(i == str_end, i1);
        }

        const StringT& name() const { return str_; }
    };

    //-------------------------------------------------------------------------
    /// rule to perform value match for std::string rvalues
    //-------------------------------------------------------------------------
    template<class CharT, class TraitsT, class AllocT>
    class r_str_t<std::basic_string<CharT, TraitsT, AllocT>> AXE_RULE
    {
        typedef std::basic_string<CharT, TraitsT, AllocT> StringT;
        StringT str_;

    public:
        r_str_t(StringT&& str) : str_(std::move(str)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(std::is_convertible<decltype(*i1), CharT>::value, "*i1 must be convertible to CharT");
            auto i = str_.begin();
            auto str_end = str_.end();
            for(; i1 != i2 && i != str_end && *i == *i1; ++i, ++i1);
            return make_result(i == str_end, i1);
        }

        const StringT& name() const { return str_; }
    };

    //-------------------------------------------------------------------------
    /// rule matches a single element satisfying predicate
    //-------------------------------------------------------------------------
    template<class Pred>
    class r_pred_t AXE_RULE
    {
        Pred pred_;
    public:
        r_pred_t(Pred&& pred) : pred_(std::forward<Pred>(pred)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return i1 != i2 && pred_(*i1) ? make_result(true, ++i1) : make_result(false, i1);
        }

        const char* name() const { return "r_pred"; }
    };

    //-------------------------------------------------------------------------
    /// rule matches a string of elements satisfying predicate
    //-------------------------------------------------------------------------
    template<class Pred, bool = false>
    class r_predstr_t AXE_RULE
    {
        Pred pred_;
    public:
        r_predstr_t(Pred&& pred) : pred_(std::forward<Pred>(pred)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            Iterator i = i1;
            for(; i != i2 && pred_(*i); ++i);
            return make_result(i != i1, i);
        }

        const char* name() const { return "r_predstr"; }
    };

    //-------------------------------------------------------------------------
    /// rule matches a string of specified length of elements satisfying predicate
    //-------------------------------------------------------------------------
    template<class Pred>
    class r_predstr_t<Pred, true> AXE_RULE
    {
        Pred pred_;
        size_t min_occurrence_;
        size_t max_occurrence_;
    public:
        r_predstr_t(Pred&& pred, size_t min_occurrence, size_t max_occurrence) 
            : pred_(std::forward<Pred>(pred)), min_occurrence_(min_occurrence), max_occurrence_(max_occurrence) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            Iterator i = i1;
            size_t count = 0;
            for(; count < max_occurrence_ && i != i2 && pred_(*i); ++i, ++count);

            return make_result(count >= min_occurrence_, i);
        }

        std::string name() const 
        { 
            std::ostringstream ss("r_predstr(pred, ");
            ss << min_occurrence_ << ", " << max_occurrence_ << ')';
            return std::move(ss).str(); 
        }
    };

    //-------------------------------------------------------------------------
    /// r_var_t rule matches a variable of type T (binary) and reads its value
    //-------------------------------------------------------------------------
    template<class T>
    class r_var_t AXE_RULE
    {
        T& t_;

    public:
        explicit r_var_t(T& t) : t_(t) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(sizeof(*i1) == 1, "iterator must be byte size for binary match");

            unsigned char* c = reinterpret_cast<unsigned char*>(&t_);
            unsigned s = 0;
            for(; s < sizeof(T) && i1 != i2; ++i1, ++s)
                c[s] = *i1;

            return make_result(s == sizeof(T), i1);
        }

        const char* name() const { return "r_var"; }
    };

    //-------------------------------------------------------------------------
    /// r_array_t rule matches static array of rules
    //-------------------------------------------------------------------------
    template<class T, size_t N>
    class r_array_t AXE_RULE
    {
        std::array<T, N>& buf_;

    public:
        explicit r_array_t(std::array<T, N>& a) : buf_(a) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            size_t s = 0;
    
            for(bool matched = true; matched && s < N && i1 != i2; ++s)
            {
                r_var_t<T> tmp(buf_[s]);
      
                result<Iterator> result = tmp(i1, i2);

                i1 = result.position_;
                matched = result.matched_;
            }

            return make_result(s == N, i1);
        }

        const char* name() const { return "r_array"; }
    };

    //-------------------------------------------------------------------------
    /// r_sequence_t rule matches and reads sequence of specified length
    //-------------------------------------------------------------------------
    template<class C>
    class r_sequence_t AXE_RULE
    {
        typedef typename C::value_type T;
        C& buf_;
        const size_t min_occurrence_;
        const size_t max_occurrence_;

    public:
        //----------------------------
        r_sequence_t(C& buf, size_t min_occurrence, size_t max_occurrence) 
            : buf_(buf), min_occurrence_(min_occurrence), max_occurrence_(max_occurrence)
        { 
            buf_.clear(); 
        }

        //----------------------------
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            size_t s = 0;
    
            for(bool matched = true; matched && i1 != i2 && s < max_occurrence_; ++s)
            {
                T t;
                result<Iterator> r = r_var_t<T>(t)(i1, i2);
                i1 = r.position_;
                matched = r.matched_;
                if(matched)
                    buf_.push_back(std::move(t));
            }

            return make_result(buf_.size() >= min_occurrence_, i1);
        }

        const char* name() const { return "r_sequence"; }
    };

    //-------------------------------------------------------------------------
    /// r_ident_t rule matches identifier
    //-------------------------------------------------------------------------
    struct r_ident_t AXE_RULE
    {
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            result<Iterator> r = r_pred_t<is_alpha>(is_alpha())(i1, i2);
            if(r.matched_)
                r = r_predstr_t<is_alnum>(is_alnum())(r.position_, i2);
            return r;
        }

        const char* name() const { return "r_ident"; }
    };

    //-------------------------------------------------------------------------
    /// r_end_t matches end of parsing range
    //-------------------------------------------------------------------------
    struct r_end_t AXE_RULE
    {
        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            return make_result(i1 == i2, i1);
        }

        const char* name() const { return "r_end"; }
    };

    //-------------------------------------------------------------------------
    /// r_advance_t succeeds when it can advance iterator by specified offset
    //-------------------------------------------------------------------------
    template<class OffsetT>
    class r_advance_t AXE_RULE
    {
        OffsetT offset_;
    public:
        
        r_advance_t(OffsetT&& offset) : offset_(std::forward<OffsetT>(offset)) {}

        template<class Iterator>
        result<Iterator> operator() (Iterator i1, Iterator i2) const
        {
            static_assert(std::is_convertible<OffsetT, 
                typename std::iterator_traits<Iterator>::difference_type>::value, 
                "offset type must be convertible to difference_type");

            bool can_advance = std::distance(i1, i2) >= 
                static_cast<typename std::iterator_traits<Iterator>::difference_type>(offset_);
            
            if(can_advance)
                std::advance(i1, offset_);

            return make_result(can_advance, i1);
        }

        const char* name() const { return "r_advance"; }
    };

    //-------------------------------------------------------------------------
    /// r_range_t creates rule from specified iterator range
    //-------------------------------------------------------------------------
    template<class Iterator>
    class r_range_t AXE_RULE
    {
       Iterator begin_, end_;
    public:
        r_range_t(Iterator begin, Iterator end): begin_(begin), end_(end) {}

        template<class I>
        result<I> operator() (I i1, I i2) const
        {
            Iterator i = begin_;
            for(; i1 != i2 && i != end_ && *i1 == *i; ++i, ++i1);
            return make_result(i == end_, i1);
        }

        const char* name() const { return "r_range"; }
    };

} // namespace

#endif
