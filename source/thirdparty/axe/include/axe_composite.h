//-----------------------------------------------------------------------------
//  Copyright (C) 2011-2012, GB Research, LLC (www.gbresearch.com)
//  
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#ifndef AXE_COMPOSITE_H
#define AXE_COMPOSITE_H

#include <utility>
#include <functional>
#include <stddef.h>
#include "axe_result.h"
#include "axe_trait.h"
#include "axe_iterator.h"
#include "axe_exception.h"

namespace axe {

//-----------------------------------------------------------------------------
/// class r_and_t defines AND operation
//-----------------------------------------------------------------------------
template<class R1, class R2>
class r_and_t AXE_RULE
{
    R1 r1_;
    R2 r2_;

public:
    r_and_t(R1&& r1, R2&& r2) : r1_(std::forward<R1>(r1)), r2_(std::forward<R2>(r2)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        result<Iterator> i = r1_(i1, i2);
        if(i.matched_)
            i = r2_(i.position_, i2);
        return i;
    }
};

//-----------------------------------------------------------------------------
/// class r_or_t defines OR operation
//-----------------------------------------------------------------------------
template<class T1, class T2>
class r_or_t AXE_RULE
{
    T1 t1_;
    T2 t2_;
    mutable unsigned index;

public:
    r_or_t(T1&& t1, T2&& t2) : t1_(std::forward<T1>(t1)), t2_(std::forward<T2>(t2)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        result<Iterator> i = t1_(i1, i2);
        index = i.matched_ ? 0 : 1;
        if(!i.matched_)
            i = t2_(i1, i2);
        return i;
    }

    unsigned which() const { return index; }
};

//-----------------------------------------------------------------------------
/// class r_xor_t defines permutation: A ^ B === A & ~B | B & ~A
//-----------------------------------------------------------------------------
template<class T1, class T2>
class r_xor_t AXE_RULE
{
    T1 t1_;
    T2 t2_;

public:
    r_xor_t(T1&& t1, T2&& t2) : t1_(std::forward<T1>(t1)), t2_(std::forward<T2>(t2)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        result<Iterator> rslt = t1_(i1, i2);
        if(rslt.matched_)
        {
            result<Iterator> rslt2 = t2_(rslt.position_, i2);
            return make_result(true, rslt2.matched_ ? rslt2.position_ : rslt.position_);
        }
        else
        {
            rslt = t2_(i1, i2);
            if(rslt.matched_)
            {
                result<Iterator> rslt2 = t1_(rslt.position_, i2);
                return make_result(true, rslt2.matched_ ? rslt2.position_ : rslt.position_);
            }
        }

        return make_result(false, i1);
    }
};

//-----------------------------------------------------------------------------
/// class r_not_t defines NOT (negation) operation
//-----------------------------------------------------------------------------
template<class R>
class r_not_t AXE_RULE
{
    R r_;

public:
    explicit r_not_t(R&& r) : r_(std::forward<R>(r)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        result<Iterator> i = r_(i1, i2);
        return make_result(!i.matched_, i1, i.position_);
    }
};

//-----------------------------------------------------------------------------
/// class r_select_t defines select rule (r1 & r2 | !r1 & r3)
//-----------------------------------------------------------------------------
template<class R1, class R2, class R3>
class r_select_t AXE_RULE
{
    R1 r1_;
    R2 r2_;
    R3 r3_;
public:
    r_select_t(R1&& r1, R2&& r2, R3&& r3) : r1_(std::forward<R1>(r1)), 
        r2_(std::forward<R2>(r2)), r3_(std::forward<R3>(r3)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        result<Iterator> match = r1_(i1, i2);
        return match.matched_ ? r2_(match.position_, i2) : r3_(i1, i2);
    }
};

//-----------------------------------------------------------------------------
/// class r_many_t defines a sequence of rules separated by separator rule
//-----------------------------------------------------------------------------
template<class R, class S>
class r_many_t AXE_RULE
{
    R r_;
    S separator_;
    const size_t min_occurrence_;
    const size_t max_occurrence_;

public:
    r_many_t(R&& r, S&& separator, size_t min_occurrence, size_t max_occurrence) 
    : r_(std::forward<R>(r)), separator_(std::forward<S>(separator)), 
    min_occurrence_(min_occurrence), max_occurrence_(max_occurrence) 
    {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2)  const
    {
        auto i_match = r_(i1, i2);
        
        if(!i_match.matched_)
            return make_result(!min_occurrence_, i1, i_match.position_);

		size_t count = 1;
		auto match = i_match;

                while(match.matched_ && count < max_occurrence_)
		{
                        match = separator_(match.position_, i2);
                        if(match.matched_)
                                match = r_(match.position_, i2);
                        if(match.matched_)
			{
				i_match = match;
				++count;
			}
		}

        return make_result(count >= min_occurrence_, i_match.position_, match.position_);
    }
};

//-----------------------------------------------------------------------------
/// class r_opt_t defines optional operation
//-----------------------------------------------------------------------------
template<class R>
class r_opt_t AXE_RULE
{
    R r_;
public:
    explicit r_opt_t(R&& r) : r_(std::forward<R>(r)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2)  const
    {
        result<Iterator> i = r_(i1, i2);
        return make_result(true, i.matched_ ? i.position_ : i1);
    }
};

//-----------------------------------------------------------------------------
/// reference wrapper (lvalues held by reference, rvalues moved)
//-----------------------------------------------------------------------------
template<class R>
class r_ref_t AXE_RULE
{
    R r_;
public:
    explicit r_ref_t(R&& r) : r_(std::forward<R>(r)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2)  const
    {
        return r_(i1, i2);
    }
};

//-----------------------------------------------------------------------------
/// rule to find specified rule (skip input elements until specified rule matched)
//-----------------------------------------------------------------------------
template<class R>
class r_find_t AXE_RULE
{
    R r_;
public:
    r_find_t(R&& r) : r_(std::forward<R>(r)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2)  const
    {
        result<Iterator> match = make_result(false, i1);

        for(; i1 != i2 && !match.matched_; ++i1)
        {
            match = r_(i1, i2);
        }

        return match;
    }
};

//-----------------------------------------------------------------------------
/// r_fail_t matches the first rule and if failed calls specified function
//-----------------------------------------------------------------------------
template<class R, class F>
class r_fail_t AXE_RULE
{
    R r_; // rule to match
    F f_; // function to call on fail
public:
    r_fail_t(R&& r, F&& f) : r_(std::forward<R>(r)), f_(std::forward<F>(f)) {}

    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2)  const
    {
        result<Iterator> match = r_(i1, i2);
        if(!match.matched_)
            f_(match.position_, i2);

        return match;
    }
};

//-----------------------------------------------------------------------------
/// r_fail_wrapper_t is used to wrap fail function
//-----------------------------------------------------------------------------
template<class F>
class r_fail_wrapper_t
{
    F f_;
public:
    r_fail_wrapper_t(F&& f) : f_(std::forward<F>(f)) {}

    F get() const { return f_; }
};

//-----------------------------------------------------------------------------
// throw_fail_t action function used in r_fail(string) to throw exception
//-----------------------------------------------------------------------------
class throw_fail_t
{
    std::string str_;
public:
    throw_fail_t(std::string str) : str_(std::move(str)) {}

    template<class Iterator>
    void operator() (Iterator i1, Iterator i2)  const
    {
        throw_failure(std::move(str_), i1, i2);
    }
};

//-----------------------------------------------------------------------------
/// r_test_t matches the specified rule, but always returns the initial iterator
//-----------------------------------------------------------------------------
template<class R>
class r_test_t AXE_RULE
{
    R r_;
public:
    r_test_t(R&& r) : r_(std::forward<R>(r)) {}
    
    template<class Iterator>
    result<Iterator> operator() (Iterator i1, Iterator i2) const
    {
        return make_result(r_(i1, i2).matched, i1);
    }
};

//-----------------------------------------------------------------------------
/// r_rule is a polymorphic rule, used primarily for defining recursive rules
//-----------------------------------------------------------------------------
template<class I>
class r_rule AXE_RULE
{
    std::function<result<I> (I,I)> fun_;
public:
    r_rule() {}

    r_rule(const std::function<result<I> (I,I)>& fun) : fun_(fun) {}

    r_rule(std::function<result<I> (I,I)>&& fun) : fun_(std::move(fun)) {}

    template<class T>
    r_rule(T&& t) : fun_(std::forward<T>(t)) {}

    r_rule<I>& operator= (const r_rule& r)
    {
        fun_ = r.fun_;
        return *this;
    }

    r_rule<I>& operator= (r_rule&& r)
    {
        fun_ = std::move(r.fun_);
        return *this;
    }

    template<class T>
    r_rule<I>& operator= (T&& t)
    {
        fun_ = std::forward<T>(t);
        return *this;
    }

    template<class Iterator>
    result<Iterator> operator()(Iterator i1, Iterator i2) const
    {
        static_assert(std::is_convertible<I, Iterator>::value, "Iterator must be convertible to I");
        return fun_(i1, i2);
    }
};

//-----------------------------------------------------------------------------
// unordered AND class (match in any order)
//-----------------------------------------------------------------------------
template<class R1, class R2>
class r_unordered_and_t AXE_RULE
{
    R1 r1_;
    R2 r2_;
public:
    r_unordered_and_t(R1&& r1, R2&& r2) : r1_(std::forward<R1>(r1)), r2_(std::forward<R2>(r2)) {}
    
    template<class Iterator>
    result<Iterator> operator()(Iterator i1, Iterator i2) const
    {
        auto match = r1_(i1, i2);
        if(match.matched)
            match = r2_(match.position, i2);
        if(!match.matched)
        {
            match = r2_(i1, i2);
            if(match.matched)
                match = r1_(match.position, i2);
        }
        return match;
    }
};

//-----------------------------------------------------------------------------
// r_seq_or_t implements R1 & R2 | R1 | R2;
//-----------------------------------------------------------------------------
template<class R1, class R2>
class r_seq_or_t AXE_RULE
{
    R1 r1_;
    R2 r2_;
public:
    r_seq_or_t(R1&& r1, R2&& r2) : r1_(std::forward<R1>(r1)), r2_(std::forward<R2>(r2)) {}
    
    template<class Iterator>
    result<Iterator> operator()(Iterator i1, Iterator i2) const
    {
        auto match = r1_(i1, i2);
        if(match.matched)
        {
            auto match1 = r2_(match.position, i2);
            return make_result(true, match1.matched ? match1.position : match.position);
        }
        return r2_(i1, i2);
    }
};

//-----------------------------------------------------------------------------
// get_name function returns rule name
//-----------------------------------------------------------------------------
template<class R>
inline auto get_name(const R& r) ->
typename std::enable_if<AXE_IS_RULE(R) && has_name<R>::value, decltype(r.name())>::type
{
    return r.name();
}

template<class R>
inline
typename std::enable_if<AXE_IS_RULE(R) && !has_name<R>::value, const char*>::type
    get_name(const R& r)
{
    return typeid(r).name();
}
//-----------------------------------------------------------------------------
// r_atomic_t matches all or nothing implements R1 & (R2 | r_fail());
//-----------------------------------------------------------------------------
template<class R1, class R2>
class r_atomic_t AXE_RULE
{
    R1 r1_;
    R2 r2_;
public:
    r_atomic_t(R1&& r1, R2&& r2) : r1_(std::forward<R1>(r1)), r2_(std::forward<R2>(r2)) {}
    
    template<class Iterator>
    result<Iterator> operator()(Iterator i1, Iterator i2) const
    {
        auto match = r1_(i1, i2);
        if(match.matched)
        {   // if r1_ matched r2_ must match too
            match = r2_(match.position, i2);
            if(!match.matched)
                throw_failure(std::string("R1 > R2 rule failed with \n   R1: ") + get_name(r1_)
                + "\n   R2: " + get_name(r2_),
                match.position, i2);

            return make_result(true, match.position);
        }
        return match;
    }
};

//-----------------------------------------------------------------------------
// skip rule
//-----------------------------------------------------------------------------
template<class R, class F>
class r_skip_t AXE_RULE
{
    R r_;
    F f_;
public:
    r_skip_t(R&& r, F&& f) : r_(std::forward<R>(r)), f_(std::forward<F>(f)) {}
    
    template<class I>
    result<I> operator() (I i1, I i2) const
    {
        auto itp(make_skip_it_pair(i1, i2, f_));
        auto rslt = r_(itp.begin(), itp.end());
        return axe::make_result(rslt.matched, rslt.position.get());
    }
};

//-----------------------------------------------------------------------------
// convert rule
//-----------------------------------------------------------------------------
template<class R, class F>
class r_convert_t AXE_RULE
{
    R r_;
    F f_;
public:
    r_convert_t(R&& r, F&& f) : r_(std::forward<R>(r)), f_(std::forward<F>(f)) {}
    
    template<class I>
    result<I> operator() (I i1, I i2) const
    {
        convert_iterator<I, F> begin(i1, f_);
        convert_iterator<I, F> end(i2, f_);
        auto rslt = r_(begin, end);
        return axe::make_result(rslt.matched, rslt.position.get());
    }
};

//-----------------------------------------------------------------------------
// buffered rule
//-----------------------------------------------------------------------------
template<class R>
class r_buffered_t AXE_RULE
{
    R r_;
public:
    r_buffered_t(R&& r) : r_(std::forward<R>(r)) {}
    
    template<class I>
    result<I> operator() (I i1, I i2) const
    {
        input_buffer<I> buf(i1, i2);
        auto begin = buf.begin();
        auto end = buf.end();
        auto rslt = r_(begin, end);
        // buffered rule must not fail, because there is no way to roll back input iterator
        if(!rslt.matched)
        {
            // copy to buffer 40 chars for reporting purposes
            auto i = rslt.position;
            std::advance(i, 40);
            throw_failure("buffered rule failed", rslt.position, i);
        }
        return axe::make_result(rslt.matched, rslt.position.get());
    }
};

//-----------------------------------------------------------------------------
// named rule
//-----------------------------------------------------------------------------
template<class R>
class r_named_t AXE_RULE
{
    R r_;
    const char* name_;
public:
    r_named_t(R&& r, const char* name) : r_(std::forward<R>(r)), name_(name) {}
    
    template<class I>
    result<I> operator() (I i1, I i2) const { return r_(i1, i2); }

    const char* name() const { return name_; }
};
}

#endif
